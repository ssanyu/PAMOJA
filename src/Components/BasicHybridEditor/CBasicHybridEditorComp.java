/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Components.BasicHybridEditor;


import Components.INodeObject;
import Components.Specifications.Language.ILanguageComp;
import Components.Specifications.Presentation.IPresentationComp;
import Nodes.CNode;
import Nodes.CNodeFactory;
import java.awt.Color;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.Serializable;

/**
 * A composite component with facilities for constructing well-formed program texts and their
 * corresponding abstract syntax tree representations by using both text and structure
 * modes of operation. 
 * <p>
 * A BasicHybridEditor component consists of an assembly of CoreHybridEditor, Text2AST, AST2Text,
 * SyntaxHighlighter and PanelTreeView PAMOJA subcomponents. It observes both a language and a presentation component, and maintains
 * consistency between its language specifications and that of the former, and between its presentation style and that of the later.
 * In addition, it makes use of a node factory tool to generate the different kinds of language-specific nodes
 * of an AST.
 * 
 * @see Components.CoreHybridEditor.CCoreHybridEditorComp
 * @see Components.Text2AST.CText2ASTComp
 * @see Components.Formatter.CAST2TextComp
 * @see Components.Lexical.SyntaxHighlighter.CSyntaxHighlighterComp
 * @see Components.Abstract.PanelTree.CPanelTreeComp
 * 
 * @author Jackline Ssanyu (jssanyu@kyu.ac.ug)
 */
public class CBasicHybridEditorComp extends javax.swing.JPanel implements INodeObject,Serializable,IBasicHybridEditorComp,PropertyChangeListener {
    private PropertyChangeSupport support= new PropertyChangeSupport(this);  
    private CNodeFactory nodeFactory;
    private ILanguageComp language;
    private IPresentationComp presentation;
    
    private CNode ast;
    private String hole;
   
    /**
     * Creates new instance of s BasicHybridEditor component.
     */
    public CBasicHybridEditorComp() {
        initComponents();
        coreHybridEditor.setText2ast(text2AST);
        coreHybridEditor.setFormatter(formatter);
        textEditor.setHybridEditor(coreHybridEditor);
        panelTree.setHybridEditor(coreHybridEditor);
        hole=new String();
        ast=null;
        formatter.setVisible(false);
        text2AST.setVisible(false);
        coreHybridEditor.setVisible(false);
        updateButtons(); 
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        abortButton = new javax.swing.JButton();
        structButton = new javax.swing.JButton();
        txtButton = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtMsgs = new javax.swing.JTextArea();
        formatter = new Components.Formatter.CAST2TextComp();
        text2AST = new Components.Text2AST.CText2ASTComp();
        jSplitPane1 = new javax.swing.JSplitPane();
        jScrollPane2 = new javax.swing.JScrollPane();
        textEditor = new Components.Lexical.SyntaxHighlighter.CSyntaxHighlighterComp();
        jScrollPane3 = new javax.swing.JScrollPane();
        panelTree = new Components.Abstract.PanelTree.CPanelTreeComp();
        jLabel3 = new javax.swing.JLabel();
        coreHybridEditor = new Components.CoreHybridEditor.CCoreHybridEditorComp();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();

        abortButton.setText("Abort");
        abortButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                abortButtonActionPerformed(evt);
            }
        });

        structButton.setText("Structure Mode");
        structButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                structButtonActionPerformed(evt);
            }
        });

        txtButton.setText("Text Mode");
        txtButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txtButtonActionPerformed(evt);
            }
        });

        txtMsgs.setColumns(20);
        txtMsgs.setRows(5);
        jScrollPane1.setViewportView(txtMsgs);

        jSplitPane1.setDividerLocation(245);
        jSplitPane1.setResizeWeight(0.5);
        jSplitPane1.setContinuousLayout(true);
        jSplitPane1.setOneTouchExpandable(true);

        jScrollPane2.setViewportView(textEditor);

        jSplitPane1.setRightComponent(jScrollPane2);

        jScrollPane3.setViewportView(panelTree);

        jSplitPane1.setLeftComponent(jScrollPane3);

        jLabel3.setText("Messages:");

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel1.setText("Structure editor:");

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel2.setText("Text editor:");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1)
            .addComponent(jSplitPane1)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(formatter, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(text2AST, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(coreHybridEditor, javax.swing.GroupLayout.PREFERRED_SIZE, 75, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(txtButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(structButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(abortButton, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(layout.createSequentialGroup()
                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 163, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 277, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 16, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 234, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(formatter, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(text2AST, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(txtButton)
                        .addComponent(structButton)
                        .addComponent(abortButton))
                    .addComponent(coreHybridEditor, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );
    }// </editor-fold>//GEN-END:initComponents
    /**
     * Handles the actionPerformed event by switching from structure mode to text mode. 
     * This involves: mapping the focus to its corresponding formated text, disabling structure mode and enabling text mode, and displaying the formated text into the text view.
     * 
     * @param evt the action event
     */
    private void txtButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txtButtonActionPerformed
        // TODO add your handling code here:
        coreHybridEditor.toText();
        textEditor.getRichTextView().setCaretColor(Color.black);
        if(!textEditor.getText().isEmpty()){
            updateButtons();
            txtMsgs.setText("");
        }
    }//GEN-LAST:event_txtButtonActionPerformed

     /**
     * Handles the actionPerformed event by switching from text mode to structure mode. 
     * This involves: mapping the text to a subtree, if successful, freeing the text view, disabling text mode and enabling structure mode, replacing a focus with the generated subtree, 
     * and refreshing the structural view. If not successful, display appropriate error message.
     * 
     * @param evt the action event
     */
    private void structButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_structButtonActionPerformed
        // TODO add your handling code here:
        txtMsgs.setText("");
        coreHybridEditor.toStructure();
        
       if(coreHybridEditor.getFocus()!=null){ 
         txtMsgs.setForeground(Color.blue);
         textEditor.getRichTextView().setCaretColor(Color.black);
         txtMsgs.setText(text2AST.getParserMsg());
       }else{
            txtMsgs.setForeground(Color.red);
            txtMsgs.setText(text2AST.getParserMsg());
            if(text2AST.getSymbolStream().symbolCount()!=0 && text2AST.getSymbolStream().getSymStart()>-1){
                textEditor.getRichTextView().setCaretColor(Color.RED);
                textEditor.getRichTextView().setCaretPosition(text2AST.getSymbolStream().getSymStart());
                textEditor.getRichTextView().requestFocusInWindow();
            } 
        
        }
        setAst(coreHybridEditor.getAst());
        updateButtons();
    }//GEN-LAST:event_structButtonActionPerformed
   /**
     * Handles the actionPerformed event by allowing a user to abort text editing. I.e switching from text mode to structure mode without mapping text to its corresponding subtree. 
     * 
     * 
     * @param evt the action event
     */
    private void abortButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_abortButtonActionPerformed
        // TODO add your handling code here:
        coreHybridEditor.abort();
        txtMsgs.setText("");
        textEditor.getRichTextView().setCaretColor(Color.black);
        updateButtons();
    }//GEN-LAST:event_abortButtonActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton abortButton;
    private Components.CoreHybridEditor.CCoreHybridEditorComp coreHybridEditor;
    private Components.Formatter.CAST2TextComp formatter;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JSplitPane jSplitPane1;
    private Components.Abstract.PanelTree.CPanelTreeComp panelTree;
    private javax.swing.JButton structButton;
    private Components.Text2AST.CText2ASTComp text2AST;
    private Components.Lexical.SyntaxHighlighter.CSyntaxHighlighterComp textEditor;
    private javax.swing.JButton txtButton;
    private javax.swing.JTextArea txtMsgs;
    // End of variables declaration//GEN-END:variables

    /**
     * Returns the AST associated with this hybrid editor component.
     * 
     * @return the AST for this hybrid editor. 
     */
    @Override
    public CNode getAst() {
        return ast;
    }

    /**
     * Sets the specified AST to this hybrid editor component, and notifies its observers.
     * 
     * @param ast the AST to set.
     */
    @Override
    public void setAst(CNode ast) {
        // set the null tree
        CNode oldAst=null;
        // assign the new value
        this.ast=ast;
        // fire the property change event, with a property that has changed
        support.firePropertyChange("ast",oldAst,this.ast);
    }

    /**
     * Access a Language component via its interface.
     *
     * @return the Language interface
     *
     */
    @Override
    public ILanguageComp getLanguage() {
        return language;
    }

     /**
     * Connects to a Language component via its interface. Registers for
     * property change events, retrieves current instance of a Language object and passes its value onto its language-dependent subcomponents.
     * 
     * @param language an instance of the Language component.
     */
    @Override
    public void setLanguage(ILanguageComp language){
      if(this.language!=null){
              this.language.removePropertyChangeListener(this);
       }
       this.language=language;
       if(this.language!=null){
              this.language.addPropertyChangeListener(this);
             
       } else {
            this.language.removePropertyChangeListener(this);
       }
       updateLanguageEnabledComponents(this.language);
       
    }

    /**
     * Access a Presentation component via its interface.
     *
     * @return the Presentation interface
     *
     */
    @Override
    public IPresentationComp getPresentation() {
        return presentation;
    }

    /**
     * Connects to a Presentation component via its interface. Registers for
     * property change events, retrieves current instance of a Presentation object and passes its value onto its presentation-dependent subcomponents.
     * 
     * @param presentation an instance of the Presentation component.
     */
    @Override
    public void setPresentation(IPresentationComp presentation){
      if(this.presentation!=null){
              this.presentation.removePropertyChangeListener(this);
       }
       this.presentation=presentation;
       if(this.presentation!=null){
              this.presentation.addPropertyChangeListener(this);
             
       } else {
            this.presentation.removePropertyChangeListener(this);
       }
       updatePresentationEnabledComponents(presentation);
     }
    
   /**
     * Returns a NodeFactory object associated with this hybrid editor.
     * 
     * @return CNodeFactory object.
     */
    @Override
     public CNodeFactory getNodeFactory() {
        return nodeFactory;
   }

     /**
     * Sets the NodeFactory to be used by this hybrid editor. In addition it passes on a nodeFactory
     * instance to CoreHybridEditor and Text2AST subcomponents.
     * 
     * @param nodeFactory the nodefactory to be set.
     */
    @Override
    public void setNodeFactory(CNodeFactory nodeFactory) {
        this.nodeFactory = nodeFactory;
        coreHybridEditor.setNodeFactory(this.nodeFactory);
        text2AST.setNodeFactory(this.nodeFactory);
        setAst(coreHybridEditor.getAst());
    }
    
    /**
     * Returns a node object associated with this hybrid editor.
     * 
     * @return the node object to return.
     */
    @Override
    public CNode getNode() {
       return coreHybridEditor.getAst();
    }

     /**
     * Handle property change events from Language and Presentation Components. If the property change is from:
     * <ul>
     * <li> <code>Language</code> - retrieve the Language object and pass on its value to the subcomponents.</li>
     * <li> <code>Presentation</code> - retrieve the Presentation object and pass its value to presentation-enabled subcomponents.</li>
     * </ul>
     * @param evt event object with the new value
     */
    @Override
    public void propertyChange(PropertyChangeEvent evt) {
         Object source = evt.getSource();
        if(source==language){
            updateLanguageEnabledComponents(language);
        }else if(source==presentation){
           updatePresentationEnabledComponents(presentation);
        }
    }
    /**
     * Helper method to update the language-dependent subcomponents of this hybrid editor with the specified language.
     * 
     * @param language the specified interface to the Language component.
     */
    private void updateLanguageEnabledComponents(ILanguageComp language){
        coreHybridEditor.setLanguage(language);
        formatter.setLanguage(language);
        text2AST.setLanguage(language);
        textEditor.setLanguage(language);
        panelTree.setLanguage(language);
        setAst(coreHybridEditor.getAst());
    }
     /**
     * Helper method to update the presentation-dependent subcomponents of this hybrid editor with the specified presentation.
     * 
     * @param presentation the specified interface to the Presentation component.
     */
    private void updatePresentationEnabledComponents(IPresentationComp presentation){
        coreHybridEditor.setPresentation(presentation);
        formatter.setPresentation(presentation);
        textEditor.setPresentation(presentation);
        panelTree.setPresentation(presentation);
    }
     /**
     * Helper method to update the enabled status of user Buttons.
     * 
     * 
     */
    private void updateButtons(){
        structButton.setEnabled(!panelTree.isStructuralMode()|| !coreHybridEditor.getTreeEditor().isTreeEditing());
        abortButton.setEnabled(!panelTree.isStructuralMode()|| !coreHybridEditor.getTreeEditor().isTreeEditing());
        txtButton.setEnabled(panelTree.isStructuralMode()  && textEditor.getText().isEmpty());
       
    }
   /**
    * Add a PropertyChangeListener to the listener list. The listener is registered for all properties.
    * 
    * @param l the PropertyChangeListener to be added 
    */
   @Override
   public synchronized void addPropertyChangeListener(PropertyChangeListener l){
       if(support!=null){
          support.addPropertyChangeListener(l);
       }
   }
    /**
    * Remove a PropertyChangeListener from the listener list. This removes a PropertyChangeListener that was registered for all properties, and has no effect if registered for only one or more specified properties. 
    * 
    * @param l the PropertyChangeListener to be removed
    */
   @Override
   public synchronized void removePropertyChangeListener(PropertyChangeListener l){
       if(support!=null){
         support.removePropertyChangeListener(l);
       }
      
   }
  
}


